# 第1章 为什么要使用Maven

Maven 是干什么用的？我们先通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。

## 1.1 第三方Jar包添加

![image-20230307153644083](https://cos.gump.cloud/uPic/image-20230307153644083.png)

在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF 目录下的 lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件。

而使用 Maven 后{==每个 jar 包只在本地仓库中保存一份==}，需要 jar 包的工程只需要维护一个文本形式的 jar 包的引用——我们称之为“坐标”。不仅极大的{++节约了存储空间++}，更{++避免了重复文件太多++}而造成的混乱。

## 1.2 第三方Jar包获取

![image-20230307153927864](https://cos.gump.cloud/uPic/image-20230307153927864.png)

JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者有同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。

使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以{==坐标==}的方式依赖一个 jar 包，Maven 就会自动从{==中央仓库==}进行下载，并同时下载这个 jar 包所依赖的其他 jar 包——规范、完整、准确！一次性解决所有问题！

## 1.3 Jar包之间的依赖关系

![image-20230307154055544](https://cos.gump.cloud/uPic/image-20230307154055544.png)

jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。

那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar 包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。

而引入 Maven 后，{==Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来==}，无需人工参与，节约了我们大量的时间和精力。用实际例子来说明就是：通过 Maven 导入 commons-fileupload-1.3.jar 后，commons-io-2.0.1.jar 会被自动导入，程序员不必了解这个依赖关系。

## 1.4 Jar包之间的冲突处理

上一点说的是 jar 包不足项目无法正常工作，但其实有的时候 jar 包多了项目仍然无法正常工作，这就是 jar 包之间的冲突。

举个例子：我们现在有三个工程 MakeFriend、HelloFriend 和 Hello。MakeFriend 依赖 HelloFriend，HelloFriend 依赖 Hello。而 Hello 依赖 log4j.1.2.17.jar，HelloFriend 依赖 log4j.1.2.14.jar。如下图所示：

![image-20230307154434681](https://cos.gump.cloud/uPic/image-20230307154434681.png)

那么 MakeFriend 工程的运行时环境中该导入 log4j.1.2.14.jar 呢还是 log4j.1.2.17.jar 呢？

这样的问题一个两个还可以手工解决，但如果系统中存在几十上百的 jar 包，他们之间的依赖关系会非常复杂，几乎不可能手工实现依赖关系的梳理。

使用 Maven 就可以自动的处理 jar 包之间的冲突问题。因为 Maven 中内置了两条依赖原则：最短路径者优先和先声明者优先，上述问题 MakeFriend 工程会自动使用 log4j.1.2.14.jar。

## 1.5 将项目拆分成多个工程模块（了解）

随着 JavaEE 项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于 JavaEE 项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个 Web 工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过 package 结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是 Java 工程，有的是 Web 工程。

那么工程拆分后又如何进行互相调用和访问呢？这就需要用到 Maven 的依赖管理机制。例如：某项目拆分的情况如下。

![image-20230307154615894](https://cos.gump.cloud/uPic/image-20230307154615894.png)

上层模块依赖下层，所以下层模块中定义的 API 都可以为上层所调用和访问。

## 1.6 实现项目的分布式部署（了解）

在实际生产环境中，项目规模增加到一定程度后，可能每个模块都需要运行在独立的服务器上，我们称之为分布式部署，这里同样需要用到 Maven。

![image-20230307154734474](https://cos.gump.cloud/uPic/image-20230307154734474.png)

