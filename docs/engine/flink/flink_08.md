# 第八章 Flink中的状态变量

- 算子状态（Operator State）
  - 算子状态的作用范围限定为算子的并行子任务，由同一并行子任务所处理的所有数据都可以访问到相同的状态。
  - 算子状态对于同一并行子任务而言是共享的。
  - 算子状态不能由相同或不同算子的另一个并行子任务访问。
  - 在 source 算子或者 sink 算子中使用，需要额外实现 `CheckpointedFunction` 接口。
- 键控状态（Keyed State）
  - 键控状态是根据输入数据流中定义的 key 来维护和访问的。
  - Flink 为每个 key 维护一个状态实例，并将具有相同 key 的所有数据，都路由到算子的同一个并行子任务中，这个并行子任务会维护和处理这个 key 对应的键控状态。
  - 当并行子任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。
    - KeyedProcessFunction: processElement(In in, ...), in 只能读写 in 的 key 对应的状态变量和定时器。
  - 键控状态的底层维护方式是在并行子任务中维护一张 HashMap。
  - 在 KeyedProcessFunction 中使用。
- 窗口状态（Windowed State）：作用域是每个窗口。
  - 在 trigger 中使用。
  - 可以在 ProcessWindowFunction 中使用。

![33](https://cos.gump.cloud/uPic/33.svg)

## Flink中的状态管理

### 状态后端

- 每传入一条数据，有状态的算子任务都会读取和更新状态。
- 由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行子任务都会在本地（任务管理器的JVM的堆内存）维护其状态，以确保快速的状态访问。
- 状态的存储、访问以及维护，由一个可插入的组件决定，这个组件就叫做状态后端（state backend）
- 状态后端主要负责两件事
  - 本地（任务管理器的JVM的堆内存）的状态管理，保证快速读写。
  - 将状态写入远程存储（HDFS、RocksDB、文件系统之类的）的检查点文件中。保证程序宕机之后可以从检查点文件进行故障恢复。

### 选择一个状态后端

- MemoryStateBackend（默认）
  - 内存级的状态后端，会将状态作为内存中的对象进行管理，将本地状态存储在任务管理器的 JVM 堆上，而将检查点文件存储在作业管理器的内存中。
  - 特点：快速、低延迟，但不稳定
- FsStateBackend（最常用）
  - 将状态存到远程的持久化文件系统（FileSystem）上面的检查点文件里面，而对于本地状态，跟 MemoryStateBackend 一样，也会存在任务管理器的 JVM 堆上。
  - 同时拥有内存级的本地访问速度，和更好的容错保证
- RocksDBStateBackend
  - 在任务管理器的 JVM 堆中，维护本地状态。将所有状态序列化后，存入 RocksDB 中。
  - RocksDB 是一个硬盘 KV 数据库。